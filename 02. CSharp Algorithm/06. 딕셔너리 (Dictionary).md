
`키(Key)`를 통해 저장된 데이터를 찾아가는 방식의 자료구조

---

# 해시테이블 (HashTable)

키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식
해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑 

---

<해시테이블 구현>
데이터를 담을 테이블을 이미 크게 확보해 놓은 후
입력받은 키를 해싱하여 테이블 고유한 index를 계산하고 데이터를 담아 보관

```
해싱
         ┌────┐
     2 ─→│    │─→   2
   998 ─→│해시│─→ 998
  2066 ─→│함수│─→  66
  8027 ─→│    │─→  27
         └────┘

  [0]   [1]   [2]        [27]        [66]       [997] [998] [999]
┌─────┬─────┬─────┬─  ─┬──────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
│     │     │  2  │....│ 8027 │....│ 2066 │....│     │ 998 │     │
└─────┴─────┴─────┴─  ─┴──────┴─  ─┴──────┴─  ─┴─────┴─────┴─────┘
```
          




<해시함수>
키값을 해싱하여 고유한 index를 만드는 함수
조건으로 하나의 키값을 해싱하는 경우 반드시 항상 같은 index를 반환해야 함
대표적인 해시함수로 나눗셈법이 있음
예시 : 2581 → (2581 % 1000) = 581


<해시테이블 주의점 - 충돌>
해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음

```
          해싱
         ┌────┐
  1081 ─→│해시│─→  81
  2081 ─→│함수│─→  81
         └────┘

  [0]   [1]   [2]          [81]          [997] [998] [999]
┌─────┬─────┬─────┬─  ─┬───────────┬─  ─┬─────┬─────┬─────┐
│     │     │     │....│ 1081 2081 │....│     │     │     │
└─────┴─────┴─────┴─  ─┴───────────┴─  ─┴─────┴─────┴─────┘
                         ↑충돌발생
```



<충돌해결방안 - 체이닝>
해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
장점 : 해시테이블에 자료사용률에 따른 성능저하가 적음
단점 : 해시테이블 외 추가적인 저장공간이 필요, 삽입삭제시 오버헤드가 발생
```
  [0]   [1]   [2]        [81]      [997] [998] [999]
┌─────┬─────┬─────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
│     │     │     │....│  │   │....│     │     │     │
└─────┴─────┴─────┴─  ─┴──│───┴─  ─┴─────┴─────┴─────┘
                          ↓
                       ┌──────┬─┐ ┌──────┬─┐
                       │ 1081 │──→│ 2081 │ │
                       └──────┴─┘ └──────┴─┘
```



<충돌해결방안 - 개방주소법>
해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
단점 : 해시테이블에 자료사용률에 따른 성능저하가 발생
```
                         
  [0]   [1]   [2]        [81]   [82]       [997] [998] [999]
┌─────┬─────┬─────┬─  ─┬──────┬──────┬─  ─┬─────┬─────┬─────┐
│     │     │     │....│ 1081 │      │....│     │     │     │
└─────┴─────┴─────┴─  ─┴──────┴──────┴─  ─┴─────┴─────┴─────┘
                         ↑2081(충돌)

  [0]   [1]   [2]        [81]   [82]       [997] [998] [999]
┌─────┬─────┬─────┬─  ─┬──────┬──────┬─  ─┬─────┬─────┬─────┐
│     │     │     │....│ 1081 │ 2081 │....│     │     │     │
└─────┴─────┴─────┴─  ─┴──────┴──────┴─  ─┴─────┴─────┴─────┘
                                ↑(다음위치에 저장)
```
<충돌해결방안 - 개방주소법:제곱법>

<충돌해결방안 - 개방주소법:이중해싱>





<해시테이블 효율>
해시테이블의 공간 사용률이 높을 경우(통계적으로 70% 이상) 급격한 성능저하가 발생
이런 경우 재해싱을 통해 공간 사용률을 낮추어 다시 효율을 확보함
재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱하여 보관
```
┌─────┬─────┬─────┬─────┬─────┐
│ 124 │ 258 │     │ 857 │ 858 │
└─────┴─────┴─────┴─────┴─────┘
  ↓ 재해싱
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ 124 │     │     │ 857 │ 858 │     │     │ 258 │     │     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
```



<해시테이블 시간복잡도>
접근       탐색       삽입       삭제
 X            O(1)       O(1)       O(1)

몇번째꺼 쓸래("예.`[2]`에 쓸래") 이게 아니고 주어진 키값으로 위치 지정하는거라. 접근 용도가 아님.
근데!! 추가 삭제 과정이 많으면 좋지 않음.
제거할때 *"여기 제거한 칸입니다"* 라고 사용불가 상태로 놔둬야함.
추가/삭제 가 잦아지면 쓸 수 없는 공간이 점점 많아진다.
70%이상 공간사용률이면 비효율적이지?
재해싱해서 비워주는 작업이 필요함. 그럼 복사하면서 시간이 늘어나겠지.

결과적으로 얘기하면, 해시테이블은 *빈번하게 추가/삭제를 반복하는 용도로 사용하지 않음*.
시간 복잡도에 속지말자!

탐색에 특화됨.







```csharp
static void Main(string[] args)
{
    // 해시테이블 기반의 HashSet 자료구조
    // 중복이 없는 해싱을 통한 빠른 탐색의 저장소
    HashSet<int> hashSet = new HashSet<int>();

    // 삽입
    hashSet.Add(1);
    hashSet.Add(3);
    hashSet.Add(4);
    hashSet.Add(5);
    hashSet.Add(2);
    hashSet.Add(3);     // 중복 추가는 무시함
    hashSet.Add(3);
    hashSet.Add(3);

    // 삭제
    hashSet.Remove(4);

    // 탐색
    hashSet.Contains(3);    // 포함 확인

    // 순회
    foreach (int value in hashSet)
    {
        Console.Write(value);   // output : 1352
    }
    Console.WriteLine();
}
```

---



그럼 해시테이블을 직접 만들어야하냐?
C#에서 만들어져있는 자료구조 `Dictionary<T>`가 있다!


# 제네릭 컬렉션 - `Dictionary<T>`
	C#에서 제공하는 해시테이블의 구현체


`Dictionary<TKey, TValue> 딕셔너리_이름 = new Dictionary<TKey, TValue>` 로 생성
키값도 제네릭. 


```csharp
static void Main(string[] args)
{
    // 해시테이블 기반의 Dictionary 자료구조
    // 중복을 허용하지 않는 key를 기준으로 해싱을 통한 빠른 탐색의 value 저장소
    Dictionary<string, PokeMon> dictionary = new Dictionary<string, PokeMon>();

    // 추가 : O(1)
    dictionary.Add("피카츄", new PokeMon("피카츄", 100));
    dictionary.Add("라이츄", new PokeMon("라이츄", 200));
    dictionary.Add("파이리", new PokeMon("파이리", 300));
    dictionary.Add("꼬부기", new PokeMon("꼬부기", 400));
    dictionary.Add("버터풀", new PokeMon("버터풀", 500));
    // dictionary.Add("피카츄", new PokeMon("피카츄", 100));  
    // error : 동일 키값의 데이터 중복 추가 불가


    // 삭제 : O(1)
    dictionary.Remove("꼬부기");

    // 탐색 : O(1)
    dictionary.ContainsKey("라이츄");                        // 포함 확인
    dictionary.TryGetValue("버터풀", out PokeMon pokeMon);   // 있으면 주고, 없음 말고
	// 있으면 out PokeMon, 없으면 false

    // 인덱서를 통한 간략한 사용
    // 탐색 후 반환(없을 시 오류)
    PokeMon findPika = dictionary["피카츄"];
    // 탐색 후 대입(없을 시 삽입)
    dictionary["피카츄"] = new PokeMon("피카츄ver2", 100);


    // 순회
    foreach (string key in dictionary.Keys)
    {
        Console.WriteLine(key);
    }
    foreach (PokeMon value in dictionary.Values)
    {
        Console.WriteLine($"{value.name} : {value.id}");
    }
}

public class PokeMon
{
    public string name;
    public int id;

    public PokeMon(string name, int id)
    {
        this.name = name;
        this.id = id;
    }
}
```



근데 Add() 말고 `dictionary[key] = value` 로 값 넣는게 더 편하지 않아? 뭔 차이지?

### 두 방식 비교: `Add()` vs `[]`

| 항목     | `Add(key, value)`                          | `dictionary[key] = value`     |
| ------ | ------------------------------------------ | ----------------------------- |
| 키 중복 시 | ❌ **오류 발생** (`ArgumentException`)          | ✔ **기존 값 덮어씀**                |
| 주 용도   | **중복되면 안 되는 값 추가**  <br>(예외 발생으로 *방어적 코딩*) | **덮어쓰기 가능** or **값 삽입 or 수정** |
| 사용 패턴  | **신규 데이터 등록 시 안전하게 사용**                    | **업데이트/수정 목적**이 더 일반적         |

- 신규 데이터 추가만 허용해야 하는 상황 → `Add()` (예: ID 중복 불가한 경우)
    
- 이미 존재할 수 있는 데이터를 "업데이트"하는 용도 → `[]` 인덱서 사용

```csharp
// 안전하게 추가하려면
if (!dictionary.ContainsKey("피카츄"))
{
    dictionary.Add("피카츄", new PokeMon("피카츄", 123));
}
// 또는 그냥 덮어쓰려면
dictionary["피카츄"] = new PokeMon("피카츄Ver2", 123);// 신규면 삽입, 기존이면 덮어쓰기
```