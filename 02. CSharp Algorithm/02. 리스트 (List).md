2025.03.28


C#에서는 `using System.Collections.Generic` 네임스페이스를 통해 
다양한 자료구조(List, Dictionary 등)의 구현체를 기본 제공한다. 
때문에 직접 구현하지 않고도 효율적인 자료구조를 사용할 수 있다.


## 리스트란?

- 배열 기반 자료구조로, 내부적으로 **동적 배열**을 사용함
- 배열과 달리 크기 제한이 없고, **자동으로 용량(Capacity)이 확장됨**
- 크기(`Count`)는 실제 요소 수, 용량(`Capacity`)은 내부 배열의 길이

---
## 리스트 내부 구조

<리스트 구현>
리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 자료구조
리스트는 동작 중 크기를 확장하기 위해 포함한 데이터보다 더욱 큰 배열을 사용

```
크기 = 3, 용량 = 8       크기 = 4, 용량 = 8       크기 = 5, 용량 = 8
┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│ │ │ │ │ │        │1│2│3│4│ │ │ │ │        │1│2│3│4│5│ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
```


<리스트 삽입>
중간에 데이터를 추가하기 위해 이후 데이터들을 뒤로 밀어내고 삽입 진행

```
     ↓                        ↓                        ↓
┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│ │ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│A│3│4│ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
```


<리스트 삭제>
중간에 데이터를 삭제한 뒤 빈자리를 채우기 위해 이후 데이터들을 앞으로 당김
```
     ↓                        ↓
┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐        ┌─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│A│3│4│ │ │ │   =>   │1│2│ │3│4│ │ │ │   =>   │1│2│3│4│ │ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘        └─┴─┴─┴─┴─┴─┴─┴─┘
```

---
# 리스트 확장
용량을 가득 채운 상황에서 데이터를 추가하는 경우
더 큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용

1. 리스트가 가득찬 상황에서 새로운 데이터 추가 시도
```
크기 = 8, 용량 = 8
┌─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│5│6│7│8│ ← A add
└─┴─┴─┴─┴─┴─┴─┴─┘
```

2. 새로운 더 큰 배열 생성
```
크기 = 8, 용량 = 8          크기 = 0, 용량 = 16
┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│5│6│7│8│ ← A add   │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

3. 새로운 배열에 기존의 데이터 복사
```
크기 = 8, 용량 = 8          크기 = 8, 용량 = 16
┌─┬─┬─┬─┬─┬─┬─┬─┐           ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│5│6│7│8│ ← A add   │1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┘           └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

4. 기본 배열 대신 새로운 배열을 사용
```
크기 = 8, 용량 = 16
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│5│6│7│8│ │ │ │ │ │ │ │ │ ← A 추가
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

5. 빈공간에 데이터 추가
```
크기 = 9, 용량 = 16
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│5│6│7│8│A│ │ │ │ │ │ │ │
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```

#### 용량 안정해둔 리스트는요?

`new List<T>(1000)` :  초기 용량 1000
	초기에 용량 1000 확보 → 1001번째 요소 추가 시 → **2000으로 확장**

`new List<T>()`  :  초기 용량 X
	첫 요소 추가 시 **기본 용량 (보통 4)로 시작**하고, 이후 **2배씩 확장** (용량이 커질수록 비효율적)
#### 결론
용량은 항상 **배수 단위로 증가**

---
List 동작 예시

```csharp
static void Main(string[] args)
{
    List<string> list = new List<string>();

    // 삽입
    // Add: 맨 뒤에 추가하기 -> O(1)
    // Insert: 중간에 끼워넣기 -> O(n)
    list.Add("0번 데이터");
    list.Add("1번 데이터");
    list.Add("2번 데이터");
    list.Insert(1, "중간 데이터1");
    list.Insert(3, "중간 데이터2");
    list.Insert(5, "끝");


    // 삭제
    // Remove: 값으로 삭제 (똑같은거 찾아서 삭제) O(n) + 당기기 O(n) -> O(n)
    // RemoveAt: 인덱스 위치에 있는 요소 삭제 후 뒷 요소들 전부 당기기 -> O(n)
    list.Remove("1번 데이터");    // 가장 앞에 있는 값 삭제
    list.RemoveAt(1);


    // 접근
    // 인덱스로 접근: O(1)
    list[0] = "데이터0";             // 리스트는 배열이기에 인덱스로 접근 가능 (할당도!)
    string value = list[0];


    // 탐색
    // 요소로 인덱스 구하기: O(n)
    int indexOf = list.IndexOf("2번 데이터");  // 찾아서 있으면 index(int),없으면 -1
    bool contain = list.Contains("3번 데이터"); // 찾아서 있으면 True, 없으면 False
	
	int count = list.Count;  // 요소 개수
	int cap = list.Capacity; // 내부 용량
	
	list.TrimExcess();          // 메모리 줄이기
	list.EnsureCapacity(2000);  // 성능 튜닝 시 용량 미리 확보
	
	//... 기능 많음!

}
```

리스트 시간복잡도

```
접근     탐색    삽입     삭제       맨뒤 삽입은 O(1)
O(1)    O(n)    O(n)    O(n)
```


### 총평 :
`List<T>`는 접근이 빠르고, 맨 뒤에 데이터를 추가할 때 효율적인 자료구조다.  
다만, 중간 삽입/삭제나 탐색은 느릴 수 있어서 너무 자주 쓰이면 성능이 떨어질 수 있음.  
따라서 **접근과 맨뒤 삽입 위주인 경우**에 쓰는 것이 좋다!

배열 밀고 당기기가 불필요한 구조면 그냥 array 써도 될듯?



---

# 배열(`Array`) vs 리스트(`List<T>`) 비교

## 크기

- **배열(`Array`)**: 고정 크기 (생성 시 결정됨)
- **리스트(`List<T>`)**: 가변 크기 (자동 확장됨)

---
## * 삽입 / 삭제

- **배열**: 중간 삽입/삭제 시 직접 요소 이동 필요
- **리스트**: `Insert()`, `Remove()` 등 메서드로 자동 처리

---
## * 접근 / 탐색 속도

| 항목     | 배열   | 리스트                          |     |
| ------ | ---- | ---------------------------- | --- |
| 인덱스 접근 | O(1) | O(1)                         |     |
| 값 탐색   | O(n) | O(n) (`Contains`, `IndexOf`) |     |

---
## * 성능과 메모리

- **배열**: 오버헤드 없음, 메모리 효율적
- **리스트**: 자동 확장에 따른 오버헤드 존재 (보통 2배로 증가)

---
## * 유연성

- **배열**: 기능 제한적 (단순 저장/읽기)
- **리스트**: 다양한 조작 메서드 제공, 유연한 사용 가능

---
## # 언제 사용할까?

| 상황                  | 추천 자료구조 |
| ------------------- | ------- |
| 크기 고정 / 빠른 반복 처리 필요 | ✅ 배열    |
| 삽입/삭제가 자주 발생하는 경우   | ✅ 리스트   |
| 성능/메모리 효율 우선        | ✅ 배열    |
| 다양한 기능 / 동적 데이터 필요  | ✅ 리스트   |

---
## 한 줄 요약

> **배열은 단순하고 빠름**  
> **리스트는 유연하고 편리함**
